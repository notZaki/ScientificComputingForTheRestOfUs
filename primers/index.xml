<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Primers on </title>
    <link>http://sciencecomputing.io/primers/</link>
    <description>Recent content in Primers on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://sciencecomputing.io/primers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advanced control flow</title>
      <link>http://sciencecomputing.io/primers/advanced_control_flow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sciencecomputing.io/primers/advanced_control_flow/</guid>
      <description>In the first lesson, we have presented the flow of execution as something largely unescapable. In practice, there are two important operations we may want to perform: skip an iteration, or stop the iteration process entirely. In this primer, we will see how this can be achieved using the break and next keywords.
Undestanding how next and break can be used is extremely useful as you start developing more complex workflows.</description>
    </item>
    
    <item>
      <title>Optimization</title>
      <link>http://sciencecomputing.io/primers/optimization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sciencecomputing.io/primers/optimization/</guid>
      <description>function initial_mutation(x) end initial_mutation (generic function with 1 method)  </description>
    </item>
    
    <item>
      <title>Map, filter, reduce</title>
      <link>http://sciencecomputing.io/primers/map_filter_reduce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sciencecomputing.io/primers/map_filter_reduce/</guid>
      <description> A lot of computing tasks involve going through arrays, or collections, of values, and selecting some of them, applying transformations, and returning values based on them. After reading the lesson on Control flow, you are equipped to do this using for, if, and while. But most tasks can actually be adressed using an approach which is even more simple: map/filter/reduce.
Map map(x -&amp;gt; x * 2, 1:5) 5-element Array{Int64,1}: 2 4 6 8 10  Filter filter(isodd, 1:5) 3-element Array{Int64,1}: 1 3 5  Reduce reduce(+, 1:3) 6  Map on slices </description>
    </item>
    
    <item>
      <title>Parallel computing</title>
      <link>http://sciencecomputing.io/primers/parallelcomputing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://sciencecomputing.io/primers/parallelcomputing/</guid>
      <description>Sometimes, we really need more than one CPU to get things done in a reasonable amount of time.
using Distributedaddprocs(2) 2-element Array{Int64,1}: 14 15  </description>
    </item>
    
  </channel>
</rss>